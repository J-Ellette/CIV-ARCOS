"""
GSN visualization for assurance cases.
Generates visual representations of argument structures using custom SVG generation.
"""

from typing import Dict, Tuple
from .case import AssuranceCase
from .gsn import GSNNodeType


class GSNVisualizer:
    """
    Generates visual representations of GSN argument structures.
    Uses custom SVG generation for visualization with optimized layouts and styling.
    """

    # Node shapes for different GSN types (for DOT generation)
    NODE_SHAPES = {
        GSNNodeType.GOAL: "rectangle",
        GSNNodeType.STRATEGY: "parallelogram",
        GSNNodeType.SOLUTION: "circle",
        GSNNodeType.CONTEXT: "rounded_rectangle",
        GSNNodeType.ASSUMPTION: "oval",
        GSNNodeType.JUSTIFICATION: "oval",
    }

    # Colors for different node types
    NODE_COLORS = {
        GSNNodeType.GOAL: "#90EE90",  # Light green
        GSNNodeType.STRATEGY: "#87CEEB",  # Sky blue
        GSNNodeType.SOLUTION: "#FFD700",  # Gold
        GSNNodeType.CONTEXT: "#F0E68C",  # Khaki
        GSNNodeType.ASSUMPTION: "#DDA0DD",  # Plum
        GSNNodeType.JUSTIFICATION: "#F5DEB3",  # Wheat
    }

    def __init__(self):
        """Initialize visualizer."""
        pass

    def to_dot(self, case: AssuranceCase) -> str:
        """
        Generate Graphviz DOT representation of the assurance case.

        Args:
            case: AssuranceCase to visualize

        Returns:
            DOT format string
        """
        lines = [
            "digraph AssuranceCase {",
            f'  label="{case.title}";',
            "  labelloc=t;",
            "  node [fontname=Helvetica, fontsize=10];",
            "  edge [fontname=Helvetica, fontsize=8];",
            "",
        ]

        # Add nodes
        for node in case.nodes.values():
            shape = self._get_dot_shape(node.node_type)
            color = self.NODE_COLORS[node.node_type]
            label = self._escape_dot_label(node.statement)

            lines.append(
                f'  "{node.id}" [label="{label}", shape={shape}, '
                f'style=filled, fillcolor="{color}"];'
            )

        lines.append("")

        # Add edges (parent-child relationships)
        for node in case.nodes.values():
            for child_id in node.child_ids:
                lines.append(f'  "{child_id}" -> "{node.id}";')

        # Add evidence links (dashed edges)
        for node in case.nodes.values():
            if node.evidence_ids:
                for evidence_id in node.evidence_ids:
                    lines.append(
                        f'  "{evidence_id}" [label="Evidence\\n{evidence_id[:16]}...", '
                        f'shape=note, style=filled, fillcolor="#FFFFFF"];'
                    )
                    lines.append(
                        f'  "{evidence_id}" -> "{node.id}" [style=dashed, label="supports"];'
                    )

        lines.append("}")
        return "\n".join(lines)

    def to_svg(self, case: AssuranceCase) -> str:
        """
        Generate SVG representation of the assurance case using custom SVG generation.

        Args:
            case: AssuranceCase to visualize

        Returns:
            SVG format string generated by custom implementation
        """
        return self._generate_basic_svg(case)

    def _generate_basic_svg(self, case: AssuranceCase) -> str:
        """
        Generate basic SVG representation as fallback.
        Uses a simple tree layout algorithm.

        Args:
            case: AssuranceCase to visualize

        Returns:
            SVG format string
        """
        # Calculate layout
        layout = self._calculate_tree_layout(case)

        svg_parts = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<svg xmlns="http://www.w3.org/2000/svg" width="800" height="600" '
            'viewBox="0 0 800 600">',
            f'  <title>{case.title}</title>',
            "",
            "  <!-- Title -->",
            f'  <text x="400" y="30" font-family="Arial" font-size="16" '
            f'text-anchor="middle" font-weight="bold">{case.title}</text>',
            "",
        ]

        # Draw edges first (so they appear behind nodes)
        svg_parts.append("  <!-- Edges -->")
        for node in case.nodes.values():
            node_pos = layout.get(node.id)
            if not node_pos:
                continue

            for child_id in node.child_ids:
                child_pos = layout.get(child_id)
                if child_pos:
                    svg_parts.append(
                        f'  <line x1="{node_pos[0]}" y1="{node_pos[1]}" '
                        f'x2="{child_pos[0]}" y2="{child_pos[1]}" '
                        f'stroke="#333" stroke-width="2"/>'
                    )

        svg_parts.append("")

        # Draw nodes
        svg_parts.append("  <!-- Nodes -->")
        for node in case.nodes.values():
            node_pos = layout.get(node.id)
            if not node_pos:
                continue

            x, y = node_pos
            color = self.NODE_COLORS[node.node_type]

            # Draw node shape
            if node.node_type == GSNNodeType.GOAL:
                # Rectangle
                svg_parts.append(
                    f'  <rect x="{x-60}" y="{y-30}" width="120" height="60" '
                    f'fill="{color}" stroke="#000" stroke-width="2" rx="5"/>'
                )
            elif node.node_type == GSNNodeType.STRATEGY:
                # Parallelogram
                svg_parts.append(
                    f'  <polygon points="{x-50},{y-25} {x+60},{y-25} '
                    f'{x+50},{y+25} {x-60},{y+25}" '
                    f'fill="{color}" stroke="#000" stroke-width="2"/>'
                )
            elif node.node_type == GSNNodeType.SOLUTION:
                # Circle
                svg_parts.append(
                    f'  <circle cx="{x}" cy="{y}" r="35" '
                    f'fill="{color}" stroke="#000" stroke-width="2"/>'
                )
            else:
                # Default: rounded rectangle
                svg_parts.append(
                    f'  <rect x="{x-60}" y="{y-30}" width="120" height="60" '
                    f'fill="{color}" stroke="#000" stroke-width="2" rx="15"/>'
                )

            # Add text (truncated)
            text = node.statement[:30] + "..." if len(node.statement) > 30 else node.statement
            svg_parts.append(
                f'  <text x="{x}" y="{y+5}" font-family="Arial" font-size="10" '
                f'text-anchor="middle">{self._escape_svg(text)}</text>'
            )

        svg_parts.append("</svg>")
        return "\n".join(svg_parts)

    def _calculate_tree_layout(
        self, case: AssuranceCase
    ) -> Dict[str, Tuple[int, int]]:
        """
        Calculate positions for nodes in a tree layout.

        Args:
            case: AssuranceCase to layout

        Returns:
            Dictionary mapping node IDs to (x, y) positions
        """
        layout = {}

        root = case.get_root_goal()
        if not root:
            return layout

        # Simple tree layout: root at top, children below
        self._layout_subtree(case, root.id, 400, 80, 800, layout, level=0)

        return layout

    def _layout_subtree(
        self,
        case: AssuranceCase,
        node_id: str,
        x: int,
        y: int,
        width: int,
        layout: Dict[str, Tuple[int, int]],
        level: int,
    ) -> None:
        """
        Recursively layout a subtree.

        Args:
            case: AssuranceCase
            node_id: Current node ID
            x: X position for this node
            y: Y position for this node
            width: Available width for children
            layout: Dictionary to store positions
            level: Current tree level
        """
        layout[node_id] = (x, y)

        node = case.get_node(node_id)
        if not node or not node.child_ids:
            return

        # Layout children
        num_children = len(node.child_ids)
        child_spacing = width / (num_children + 1)
        child_y = y + 100

        for i, child_id in enumerate(node.child_ids):
            child_x = int(x - width / 2 + child_spacing * (i + 1))
            child_width = max(width // num_children, 100)
            self._layout_subtree(
                case, child_id, child_x, child_y, child_width, layout, level + 1
            )

    def _get_dot_shape(self, node_type: GSNNodeType) -> str:
        """Get Graphviz shape for node type."""
        shape_map = {
            GSNNodeType.GOAL: "box",
            GSNNodeType.STRATEGY: "parallelogram",
            GSNNodeType.SOLUTION: "circle",
            GSNNodeType.CONTEXT: "note",
            GSNNodeType.ASSUMPTION: "oval",
            GSNNodeType.JUSTIFICATION: "oval",
        }
        return shape_map.get(node_type, "box")

    def _escape_dot_label(self, text: str) -> str:
        """Escape text for DOT format."""
        # Truncate long text
        if len(text) > 50:
            text = text[:47] + "..."
        # Escape quotes and newlines
        text = text.replace('"', '\\"').replace("\n", "\\n")
        return text

    def _escape_svg(self, text: str) -> str:
        """Escape text for SVG format."""
        return (
            text.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;")
            .replace("'", "&apos;")
        )

    def generate_summary(self, case: AssuranceCase) -> Dict[str, any]:
        """
        Generate a summary of the assurance case structure.

        Args:
            case: AssuranceCase to summarize

        Returns:
            Summary dictionary
        """
        summary = {
            "case_id": case.case_id,
            "title": case.title,
            "description": case.description,
            "project_type": case.project_type,
            "node_count": len(case.nodes),
            "node_counts_by_type": {},
            "evidence_count": 0,
            "max_depth": 0,
        }

        # Count nodes by type
        for node in case.nodes.values():
            node_type = node.node_type.value
            summary["node_counts_by_type"][node_type] = (
                summary["node_counts_by_type"].get(node_type, 0) + 1
            )
            summary["evidence_count"] += len(node.evidence_ids)

        # Calculate max depth
        if case.root_goal_id:
            summary["max_depth"] = self._calculate_max_depth(case, case.root_goal_id)

        return summary

    def _calculate_max_depth(self, case: AssuranceCase, node_id: str, depth: int = 0) -> int:
        """Calculate maximum depth of the argument tree."""
        node = case.get_node(node_id)
        if not node or not node.child_ids:
            return depth

        max_child_depth = depth
        for child_id in node.child_ids:
            child_depth = self._calculate_max_depth(case, child_id, depth + 1)
            max_child_depth = max(max_child_depth, child_depth)

        return max_child_depth
